"""
serial_repl.py -- a particularly dirty, hacky thing designed to run a repl loop over the UART on my Pi Pico.
(C) 2022 B.M.Deeal
distributed under the ISC license, see <https://opensource.org/licenses/ISC> for details

This was mostly intended so I could attach my Pico to my Windows CE systems over serial.
There is almost certainly a better way to do this (probably involving a recompiled micropython binary), but this was fun to write.

Configure your device to emit only ^M (CR) for enter, and ^H for backspace. Disable local echo.
Pressing ^J will emit a newline (LF), which will allow you to add multiple lines to your input.
Run show_help() to see the rest of the available keys.
load_and_patch() monkey-patches the print/input functions for any scripts you want to load and run.
"""

from machine import UART, Pin
import time
import os
import sys
uart0 = UART(0, baudrate=9600, tx=Pin(0), rx=Pin(1))

debug=False #mostly enables some debug info on stdout
led_enable=True #enables the LED flashing when you type (you might want to disable this if your program uses the LED)
true_tty=False #disables moving the cursor backwards with backspace since that'll overtype

if led_enable:
    led = Pin(25, Pin.OUT)

def set_led_on():
    """turn on the LED if LED control enabled"""
    if led_enable:
        led.on()
        
def set_led_off():
    """turn off the LED if LED control enabled"""
    if led_enable:
        led.off()

def out_chr(n):
    """write a character index to the attached terminal"""
    uart0.write(chr(n))

def out_str(s=""):
    """write a string, no newline, to the attached terminal"""
    uart0.write(str(s))

def out_nl():
    """write a newline to the attached terminal"""
    uart0.write("\r\n")
    time.sleep_ms(200)

def out_line(s="", *args, **kwargs):
    """write a full line to the attached terminal"""
    #args and kwargs are ignored and are there only for compatibility with print()
    #TODO: should do some checks and actually call print if it redirects
    out_str(s)
    out_nl()

def in_line(txt=""):
    """read a line from the attached terminal"""
    global in_line_prev
    line=[]
    out_str(txt)
    while True:
        #check if any data is to be read
        set_led_off()
        if uart0.any()>0:
            for ch in uart0.read():
                set_led_on()
                #accept entry
                if ch==13: #enter/carriage return -- my device doesn't do \n, just \r
                    #join everything into a final result
                    result=bytes(line).decode("ascii")
                    set_led_off()
                    if debug:
                        print(f"sent '{result}'")
                    out_nl()
                    in_line_prev=line
                    return result
                #debug print info
                if debug:
                    print(f"{ch}='{chr(ch)}'")
                #accept a newline as something you can enter
                if ch==10:
                    out_line("\\") #emit a character to indicate
                    line.append(ch)
                #echo typed valid characters (so, don't use local echo)
                if (ch>=32 and ch<=126): #printable characters
                    out_chr(ch) #uart0.write(chr(ch))
                    line.append(ch)
                #we don't bother with real tabs on input
                if ch==9: #tab
                    out_str("    ")
                    line.append(ch)
                #clear buffer
                if ch==21: #NAK, generated by ^U
                    line=[]
                    out_line("...erased\\")
                #load previously typed input
                #TODO: refactor character output
                if ch==6: #ACK, generated by ^F
                    out_line("...loaded\\")
                    line=in_line_prev.copy()
                    for cc in line:
                        if cc==10:
                            out_line("\\")
                            out_nl()
                        elif cc==9:
                            out_str("    ")
                        else:
                            out_chr(cc)
                #backspace -- mostly does the right thing visually, breaks on my terminal if the text crosses to a newline
                if ch==8 and len(line)>0:
                    prev_ch=line.pop()
                    if not true_tty:
                        #undo the last 4 spaces for tab
                        if prev_ch==9:
                            out_chr(8)
                            out_chr(8)
                            out_chr(8)
                            out_chr(8)
                            #forces the cursor to update
                            out_chr(32)
                            out_chr(8)
                        #any single-character, we can go back, clear, go back
                        else:
                            out_chr(8)
                            out_chr(32)
                            out_chr(8)
                    else:
                        out_str("^H")
in_line_prev=[] #dirty hack; this whole program needs a refactor

def input_test():
    """for testing whether things work"""
    out_nl()
    uart0.write("test data: ")
    in_line()

def ls(location="."):
    """show a listing of the current directory"""
    for fname in os.listdir():
        out_line(fname)

def reboot():
    """restart the system"""
    machine.reset()

def bye():
    """exit this REPL system"""
    sys.exit()

def show_help():
    """display some commands and keys"""
    out_line("serial_repl.py -- connect a UART terminal to the Pi Pico")
    out_line("by B.M.Deeal.")
    out_line("Use load_and_patch('name') to load a program.")
    out_line("This will redefine print() and input() for them.")
    out_line("bye() will return to the USB REPL.")
    out_line("ls() will show a dir listing.")
    out_line("reboot() will restart the Pico.")
    out_line("Use out_line() instead of print() to write to the terminal.")
    out_line("Use in_line() instead of input() to read from the terminal.")
    in_line("Press enter to continue...")
    out_line("^M will submit input.")
    out_line("^J will add a newline to the buffer.")
    out_line("^H will backspace a character from the buffer.")
    out_line("^U will clear the input buffer.")
    out_line("^F will load the last submitted line to the buffer.")

def repl():
    """main read-eval-print loop"""
    #intro text, two newlines to skip past any garbage that may have been sent
    out_nl()
    out_nl()
    out_line("Type show_help() to view help.")
    out_line("^M will submit input.")
    out_line("REPL ready.")
    user_input=""
    result=""
    while True:
        #read and evaluate input
        try:
            out_str(">>>")
            user_input=in_line()
            result=eval(user_input)
            if result is not None:
                out_line(result)
        #we try to emit the result if we can, so we have to switch between eval and exec
        #if exec returned a value, none of this would be needed
        except SyntaxError:
            try:
                exec(user_input)
            #real syntax error
            except Exception as ex2:
                out_line(ex2)
        #could not parse
        except Exception as ex:
            out_line(ex)

def main():
    """run the main loop"""
    time.sleep_ms(900) #the pico spews a bit of garbage, so we wait a bit
    repl()

def load_and_patch(s):
    """monkey-patch other scripts so they output over serial -- this is NOT robust at all"""
    exec(f"import {s}\n{s}.input=in_line\n{s}.print=out_line")


if __name__=="__main__":
    main()
